---
title: "Single cell analysis"
author: "Giulio Scarpa and Giovanni Marteletto"
date: "16/6/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

## Quality Control and Setup

First of all we need to load the libraries needed

```{r}
rm(list = ls())

library(dplyr)
library(Seurat)
library(patchwork)
library(stringr)
library(ggplot2)
```

We load the previously downloaded dataset from PanglaoDB.
Before creating the object we will work on, we need to change the identification of the genes in a more interpretable notation, such as gene symbols. So we need to split the rownames and take only the gene symbol id.

```{r}
load('./SRA779509_SRS3805265.sparse.RData')

# cutting all the part after the gene symbol
rownames(sm) <- lapply(rownames(sm), FUN = function(x){
  if (str_count(x, '_') != 1){
    a <- strsplit(x, '_')
  x <- paste(a[[1]][1], a[[1]][2], sep='_')
  }
  else{
    x <- strsplit(x, '_')[[1]][1]
  }
})
```

We can proceed with the creation of the Seurat object.
As a first filtering step we eliminate cells in which there are less than 200 genes expressed and also all the genes that are expressed in less than 3 cells

```{r}
pbmc <- CreateSeuratObject(sm,  project = "Bone_Marrow",  min.cells = 3,  min.features = 200)
head(rownames(pbmc), n=30)
```

## Quality Control

In this stage we check for different parameters that allows us to infer the quality and reliability of the data coming from the cells. In particular we look at the number of features, the % of ribosomal protein genes and mitochondrial genes.

These genes are identified by their prefixes

```{r}
# calculate mitochondrial percentage in scRNA-Seq count tables, i.e. all genes starting with MT-
pbmc[["percent.mt"]] <- PercentageFeatureSet(pbmc, pattern = "^MT-")

# same for ribosomal proteins
pbmc[["percent.rbp"]] <- PercentageFeatureSet(pbmc, pattern = "^RP[LS]")

# showing the number of RNA transcript per cell
head(pbmc@meta.data, 5)
```

At this point we can use plots to visualize the quality parameters

```{r}
#plotting data and computed percentages as violin plot
#now we are able to check the quality of the parameters an decide which cells to keep
VlnPlot(pbmc, features = c("nFeature_RNA", "nCount_RNA",  "percent.mt",  "percent.rbp"), 
        ncol =4, cols=c("red2"))
```

By looking at the violin plots we decided that 9% was a good cut-off for the mitochondrial genes.

We can also look at the relationship between these parameters to see if they are related.

```{r}
FeatureScatter(pbmc, feature1 =  "nCount_RNA", feature2 =  "percent.mt", cols = 'red2') # on the top of the graph you can see the correlation coefficient, but just looking at the plot we can clearly see that there's no correlation
FeatureScatter(pbmc, feature1 = "nCount_RNA", feature2 =  "nFeature_RNA", cols = 'red2')# here we can see that in fact there's correlation between the number of expressive genes and the number of reeds in our sample
FeatureScatter(pbmc, feature1 = "nCount_RNA", feature2 = "percent.rbp", cols = 'red2')# no correlation
```

After looking at the violin plot of gene expression, we decided to use as limit the following cutoff:
*   less than 9% mitochondrial genes
*   more than 250 features
*   less than 2000 features

```{r}
pbmc <- subset(pbmc, subset = nFeature_RNA > 250 & nFeature_RNA < 2000 & percent.mt < 9)
```

Inspecting the Seurat object we can make the comparison between before and after the cell filter
22713 genes across 6937 cells before filtering
22713 genes across 6086 cells after filtering

For 10x data the normalization is done just by multiplying the number of counts of a gene for 10000 to make it more readable and then compute the logarithm of the normalized counts. After scaling we compute the log2-counts per million of each gene across the cells.
We inspect the counts and normalized counts

```{r, results='hide'}
pbmc <- NormalizeData(pbmc, normalization.method = "LogNormalize", scale.factor = 10000)

#counts
head(pbmc@assays$RNA@counts)
#normalized counts
head(pbmc@assays$RNA@data)
```

Now we check genes related to the regulation of cell cycle. The goal is to know if the similarity within cells in my cluster is given only by non-cycle related genes or if they play a role in the classification of the cells.

```{r}
pbmc <- CellCycleScoring(pbmc, s.features = cc.genes.updated.2019$s.genes, 
                         g2m.features = cc.genes.updated.2019$g2m.genes, set.ident =TRUE)
head(pbmc[[]])
```

Each cell is a point in a n-dimensional space, where n is the number of genes considered. The closer are two points the more similar are the transcriptomes of the corresponding cells. However, the dimensions are too many for further processing. Also, most of the coordinates of each cell would be zero. So, a better strategy is to keep a subset of the genes, that is, those with the greatest variability of expression across cells.

The default method 'vst' estimates the mean-variance relationship of each gene, and chooses the 2000 
genes with the highest variance. With this method we can discard most of the 0 expression genes, the housekeeping genes and all those which presents an overexpression in just a couple of cells

```{r}
pbmc <- FindVariableFeatures(pbmc, selection.method = "vst", nfeatures = 2000)
```
Identifying the 10 most highly variable genes and visualizing them.

```{r}
top10 <- head(VariableFeatures(pbmc), 10)

plot1 <- VariableFeaturePlot(pbmc)
LabelPoints(plot = plot1, points = top10, repel = TRUE)
```

The next step is to scale the counts to shift the expression of each gene, so that the mean expression across cells is 0 and the variance across cells is 1.

```{r}
all.genes <- rownames(pbmc)
pbmc <- ScaleData(pbmc, features = all.genes) # Centering and scaling data matrix
```
In this step we can remove unwanted effects so it's a good idea to check for example if the Cell Cycle genes are interfering with the clustering.

We run a PCA to first check if there is an association between the cells given only by the cell cylce phase and we can plot the results

```{r}
pbmc <- RunPCA(pbmc, features = VariableFeatures(object = pbmc))

print(pbmc[["pca"]], dims = 1 : 5, nfeatures = 5)
```

Here we chose to inspect 5 of the most expressed genes among the first five principal components

*   PC_ 1
*       IL32: pro inflamatory cytokine higher in mammal not in rodents
*       TRAC: T Cell Receptor Alpha Constant
*       S100A9: calcium- and zinc-binding protein has a role in regulation of inflammatory processes

*   PC_ 2
*       IGHM: Immunoglobulins (Ig) are the antigen recognition molecules of B cells
*       GNLY:   anti-microbical peptide released by killer lymphocytes

```{r}
VizDimLoadings(pbmc, dims = 1 : 2, reduction = "pca")
```


The following plot allow us to know if they clusters based on cell cycle

```{r}
DimPlot(pbmc, reduction = "pca")
```
We can see that there aren't any discernible clusters grouping together cells based on cell cycle phase so we do not need to worry about it too much downstream, we don't need to regress out this effect.

At this point we proceed with the Principal Component number selection.
We want a proper balance, if we don't use enough PCs the risk is to have a big portion of the variability unexplained by the final clustering, on the other hand if we use too many PCs the risk is to introduce noise and cluster cell types as different even when they are not.

We choose to proceed in two ways:

*   The first by visualizing the elbow plot and assessing when the curve reaches a plateau.

*   The second by using a mathematical approach that keep all the PC until 70-75% of the variance is explained

```{r}
#Elbow plot
ElbowPlot(pbmc, ndims= 30)

pc.touse <- (pbmc$pca@stdev)^2
pc.touse <- pc.touse/sum(pc.touse)
pc.touse <- cumsum(pc.touse)[1:50]
pc.touse <- min(which(pc.touse>= 0.75))
pc.touse
```

Looking at the Elbowplot, we decided for 20 PCs.
The mathematical computation returns a value of 22 PCs. In further analysis we will use both number of PCs and compare them at the end. For now, let's keep the PCs number as 20.

```{r}
pbmc <- FindNeighbors(pbmc, dims = 1:20)
```

Here, we decided to choose a resolution value within the range suggested by the authors (0.4-1.2), even if their dataset is about 3K cells large, in our case we have 6k cells.
We tested and arrived at the conclusion that if the resolution value is too high it becomes difficult to represent the clusters in a nice way.

So we decided to use resolution = 0.7 because otherwise we noticed that there would be too many clusters which most of them we would have to cluster together later according to gene expression
```{r}
pbmc <- FindClusters(pbmc, resolution = 0.7)
```

We compute the number of cells per cluster.

```{r}
Cells_clusters <- data.frame(matrix(NA, nrow = 13, ncol = 2))
rownames(Cells_clusters) <- 0:12
colnames(Cells_clusters) <- c('Cluster','Cells')

for (n in rownames(Cells_clusters)){
  Cells_clusters[n,2] <- length(Idents(pbmc)[Idents(pbmc) == n])
  Cells_clusters[n,1] <- as.character(n)
}

Cells_clusters
```

plotting all clusters in a bidimentional space composed by the first two PCA

```{r}
DimPlot(pbmc, reduction = "pca")
```

This a demonstration that only using the first two PCs leads to a good clustering result

```{r}
DimPlot(pbmc,reduction= "pca", dims=c(8, 19))
DimPlot(pbmc,reduction= "pca", dims=c(2, 12))
```

Now we try other methods of dimentionality reduction.
tSNE

```{r}
pbmc <- RunTSNE(pbmc, dims= 1:20)
DimPlot(pbmc, reduction = "tsne")
```

In the end we decided to use UMAP because the clusters are better represented.

```{r}
pbmc <- RunUMAP(pbmc, dims =  1:20)
DimPlot(pbmc, reduction ="umap")
```

Note: We also did the same analysis but using a different number of PCs and resolution at the clustering phase as an experiment of comparison between the PCs chosen looking at the elbowplot and the number found with the mathematical procedure. We didn't went on with the alternative method (the math one) and choosed to proceed with only the results coming from the graphical method.


## Clusters and Marker genes analysis

Now we can proceede by checking for example the quality parameters and how are they distributed in each cluster. This is a good way of informing if the clusters are divided by other parameters than differential expression of genes.

```{r}
VlnPlot(pbmc,features= "nCount_RNA")
VlnPlot(pbmc,features= "nFeature_RNA")
VlnPlot(pbmc,features= "percent.mt")
VlnPlot(pbmc,features= "percent.rbp")
```

Cell Cycle quality plot

```{r}
pbmc@meta.data %>%
  group_by(seurat_clusters,Phase) %>%
  count() %>%
  group_by(seurat_clusters) %>%
  mutate(percent= 100*n/sum(n)) %>%
  ungroup() %>%
  ggplot(aes(x=seurat_clusters,y=percent, fill=Phase)) +
  geom_col() +
  ggtitle("Percentage of cell cycle phases per cluster")
```

we return only genes (top 5 for eache cluster) "over expressed", found in at least 25% of the cells, and with a logFC threshold of at least 0.25.

```{r}
pbmc.markers <- FindAllMarkers(pbmc, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)
pbmc.markers %>%
  group_by(cluster) %>%
  slice_max(n = 5, order_by = avg_log2FC) -> top5 # ordered by logFC

pbmc.markers %>%
  group_by(cluster) %>%
  slice_min(n = 2, order_by = p_val_adj ) # top 2 ordered by FDR

pbmc.markers %>%
  group_by(cluster) %>%
  top_n(n = 10, wt = avg_log2FC) -> top10
```

In the end we choose the logFC among the FDR as oredering factor beacuse it represents better the overexpression of the genes.

It is useful to get some visualization of the genes expressend on the clusters. The next plots shows the top genes for each clusters. By looking at them we can see if they are really representative of the cell type or not.


```{r}
# cluster specific gene expression
FeaturePlot(pbmc, features = c('LEF1', 'GZMK', 'S100A8', 'GNLY', 'IGKC', 'DUSP2', 'CA1', 'IGLC2', 'FXYD5', 'LST1', 'HBA1', 'JCHAIN', 'HLA-DRA'))

DotPlot(pbmc, features = c('LEF1', 'GZMK', 'S100A8', 'GNLY', 'IGKC', 'DUSP2', 'CA1', 'IGLC2', 'FXYD5', 'LST1', 'HBA1', 'JCHAIN', 'HLA-DRA'))
```

The overall expression heatmap helps us to detect and investigate further the cluster similarity, exposing the similarity between cluster 2 and 9 and  between cluster 4 and 7.

```{r}
pbmc.markers %>%
  group_by(cluster) %>%
  top_n(n = 10, wt = avg_log2FC) -> top10
DoHeatmap(pbmc, features = top10$gene) + NoLegend()
```

there are indeed some clusters sharing very similar overexpressed genes.
We proceed with the inspection of the markers in clusters 9 and 2 to verify if they are the same cell type.

```{r}
# non parametric wilcox test to find all markers of cluster 2 vs. all the others
cluster2.markers <- FindMarkers(pbmc, ident.1 = 2, min.pct = 0.25, test.use = "wilcox")
cluster2.markers <- cluster2.markers[order(-cluster2.markers$avg_log2FC),]
head(cluster2.markers, n = 10)
```

```{r}
# non parametric wilcox test to find all markers of cluster 9 vs. all the others
cluster9.markers <- FindMarkers(pbmc, ident.1 = 9, min.pct = 0.25, test.use = "wilcox")
cluster9.markers <- cluster9.markers[order(-cluster9.markers$avg_log2FC),]
head(cluster9.markers, n = 10)
```
```{r}
# Here we compare gene expression of both the clusters against all the other 
cluster9AND2.markers <- FindMarkers(pbmc, ident.1 = c(9, 2), min.pct = 0.25, test.use =  "wilcox")
cluster9AND2.markers <- cluster9AND2.markers[order(-cluster9AND2.markers$avg_log2FC),]
head(cluster9AND2.markers, n = 10)
```

```{r}
# Comparing difference in expression between cluster 9 and 2 to highlight genes overexpressed in cluster 9 
# in respect to cluster 2 did lead to any particular marker
cluster9_2.markers <- FindMarkers(pbmc, ident.1 = 9, ident.2 = 2, min.pct = 0.25, test.use = "wilcox")
cluster9_2.markers <- cluster9_2.markers[order(-cluster9_2.markers$avg_log2FC),]
head(cluster9_2.markers, n = 10)
```

In the end we can conclude that there is no evidence to posit that cluster 9 express any marker which lead to a different cell type compared to cluster 2 so we decide to merge them.

We performed the same procedure for the other 2 clusters

```{r}
# Same procedure for the other two clusters 
cluster74.markers <- FindMarkers(pbmc, ident.1 = 7, ident.2 = 4, min.pct = 0.25, test.use = "wilcox")
cluster74.markers <- cluster74.markers[order(-cluster74.markers$avg_log2FC),]
head(cluster74.markers, n = 10)

cluster86.markers <- FindMarkers(pbmc, ident.1 = 8, ident.2 = 6, min.pct = 0.25, test.use = "wilcox")
cluster86.markers <- cluster86.markers[order(-cluster86.markers$avg_log2FC),]
head(cluster86.markers, n = 10)
```

Merging them together

```{r}
Idents(pbmc)[Idents(pbmc) == 9] <- 2
Idents(pbmc)[Idents(pbmc) == 7] <- 4
```


Finally we have all markers which identify unequivocally all the cell types of all the 11 clusters

*   0 LEF1, CCR7 -> Naive CD4+ T-cell(https://en.wikipedia.org/wiki/Lymphoid_enhancer-binding_factor_1, https://www.proteinatlas.org/ENSG00000126353-CCR7)
*   1 GZMK, IL7R -> MAIT T-cell (https://www.proteinatlas.org/ENSG00000113088-GZMK, https://www.proteinatlas.org/ENSG00000168685-IL7R, )
*   2 S100A8, S100A9, LYZ -> Classical Monocyte (https://www.proteinatlas.org/ENSG00000143546-S100A8, https://www.proteinatlas.org/ENSG00000090382-LYZ)
*   3 GNLY, GZMB -> NK-cells (https://www.proteinatlas.org/ENSG00000115523-GNLY, https://www.proteinatlas.org/ENSG00000100453-GZMB)
*   4 IGKC, IGLC2-> Plasmablast (https://www.proteinatlas.org/ENSG00000211592-IGKC, https://www.proteinatlas.org/ENSG00000211677-IGLC2)
*   5 CCL5, TRGC2 -> GdT-cells ( https://www.proteinatlas.org/ENSG00000271503-CCL5/immune+cell)
*   6 CA1, HBM, HBD -> Naive B-cell (https://www.proteinatlas.org/ENSG00000133742-CA1/immune+cell, https://www.proteinatlas.org/ENSG00000206177-HBM/immune+cell)
*   8 LTB, TRAC  -> Memory CD4+ (https://www.proteinatlas.org/ENSG00000227507-LTB/immune+cell, https://www.proteinatlas.org/ENSG00000277734-TRAC/immune+cell)
*   10 HBA2, HBB -> Exhausted memory B-cell (https://www.proteinatlas.org/ENSG00000188536-HBA2/immune+cell, https://www.proteinatlas.org/ENSG00000244734-HBB/immune+cell)
*   11 IRF7, ITM2C, IRF8 -> Plasmacytoid DC (https://www.proteinatlas.org/ENSG00000185507-IRF7/immune+cell, https://www.proteinatlas.org/ENSG00000135916-ITM2C/immune+cell, https://www.proteinatlas.org/ENSG00000140968-IRF8/immune+cell)
*   12 HLA-DRA, HLA-DPB1, HLA-DRB1-> Myeloid DC (https://www.proteinatlas.org/ENSG00000204287-HLA-DRA/immune+cell, https://www.proteinatlas.org/ENSG00000223865-HLA-DPB1/immune+cell)

```{r}
pbmc.markers %>%
  group_by(cluster) %>%
  top_n(n = 10, wt = avg_log2FC) -> top10
DoHeatmap(pbmc, features = top10$gene) + NoLegend()
```

We can visualize how the cluster specific genes are expressed within the clusters and their distribution

```{r}
#cell type defining markers
VlnPlot(pbmc, features = c('HBA2'))
VlnPlot(pbmc, features = c('HLA-DPB1'))
VlnPlot(pbmc, features = c('S100A8'))
VlnPlot(pbmc, features = c('GNLY'))
```

Visualize co-expression of two features simultaneously

```{r}
FeaturePlot(pbmc, features = c("LEF1", "GZMK"), blend = TRUE)
```
We can finally define our clusters as specific cell types

```{r}
new.cluster.ids <- c('Naive CD4+ T-cell', 'MAIT T-cell','Classical Monocyte', 'NK-cells', 'Plasmablast', 
                     'GdT-cells', 'Naive B-cell', 'Memory CD4+', 'Exhausted memory B-cell', 'Plasmacytoid DC', 'Myeloid DC')

names(new.cluster.ids) <- levels(pbmc)
pbmc <- RenameIdents(pbmc, new.cluster.ids)
DimPlot(pbmc, reduction = "umap", label = TRUE, pt.size = 0.5) + NoLegend()
```










